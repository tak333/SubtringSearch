#include "StringSearch.h"

#include <stdlib.h>
#include <string.h>

static const size_t NOT_A_POSITION = -1;
static const int MEMORY_ALLOCATION_ERROR = -1;

//Префикс-функция
size_t* get_prefix(const char* s, size_t n)
{
	//массив результатов префикс-функции для строки:
	size_t* prefix = malloc(sizeof(size_t) * n);

	if (prefix == NULL)
	{
		exit(MEMORY_ALLOCATION_ERROR);
	}

	prefix[0] = 0;

	//на каждом шаге проверяем подстроку [0 ... i]
	//j - последний проверяемый символ префикса
	//i - последний проверяемый символ суффикса
	//общая схема:
	//[|0..префикс...j|....что-то.....|суффикс....i|]
	size_t j = 0, i = 1;

	//пока не переберём все подстроки, которые заканчиваются на i:
	while (i < n)
	{
		//если символы префикса и суффикса совпадают для строки i:
		if (s[j] == s[i])
		{
			//сохраняем накопленное значение длин в таблицу:
			prefix[i] = j + 1;
			//жадно берём дальше (т.е. увеличиваем и префикс, и суффикс на 1):
			++j;
			++i;
		}
		//если символы префикса и суффикса НЕ совпали для строки i:
		else
		{
			//указываем ей, что префикс и суффикс не совпали, т.е. длина = 0:
			prefix[i] = 0;

			//если префикс не накопился, то переходим к новой строке i:
			if (j == 0)
				++i;
			//если префикс хоть немного накопился, то откатываемся к предыдущему накопленному варианту
			//и начинаем проверку ЗА успешной строкой, т.е. j = кол-ву сивмолов в строке:
			else
				j = prefix[j - 1];
		}
	}

	//возвращаем массив результата префикс-функции:
	return prefix;
}

//Получение таблицы сдвигов для "плохих" символов
size_t* get_symbol_table(const char* s, size_t n)
{
	//мощность алфавита:
	const size_t alp = 256;

	//таблица сдвигов для всех символов:
	size_t* table = malloc(sizeof(size_t) * alp);

	if (table == NULL)
	{
		exit(MEMORY_ALLOCATION_ERROR);
	}

	//заполнение максимальным сдвигом (= длине строки):
	for (size_t i = 0; i < alp; ++i)
	{
		table[i] = n;
	}

	//проходим по всем символам строки с конца:
	for (size_t k = 1; k < n; ++k)
	{
		//символ преобразовывается к индексу в таблице сдвигов:
		unsigned char index = s[n - 1 - k];

		//если сдвиг ещё не был записан в таблицу, обновляем его:
		//(таким образом, для повторяющегося символа записывается минимальное расстояние от этого символа до конца строки)
		if (table[index] == n)
		{
			table[index] = k;
		}
		//table[index] = min(table[index], k);
	}

	//возврат таблицы сдвигов символов:
	return table;
}

//Получение перевёрнутой строки
char* get_reversed(const char* s, size_t n)
{
	char* reversed = malloc(n);

	if (reversed == NULL)
	{
		exit(MEMORY_ALLOCATION_ERROR);
	}

	for (size_t i = 0; i < n; ++i)
	{
		reversed[i] = s[(n - 1) - i];
	}

	return reversed;
}

//Переворот массива чисел
void reverse(size_t* arr, size_t n)
{
	for (size_t i = 0; i < n / 2; ++i)
	{
		size_t buffer = arr[i];
		arr[i] = arr[n - 1 - i];
		arr[n - 1 - i] = buffer;
	}
}

//"Суффикс"-функция 
size_t* get_suffix(const char* s, size_t n)
{
	//получение перевёрнутой строки для подсчёта суффиксов, а не префикксов:
	char* reversed = get_reversed(s, n);

	//массив результатов суффикс-функции для строки:
	size_t* suffix = get_prefix(reversed, n);

	free(reversed);

	//возвращаем таблицу суффиксов:
	return suffix;
}

//Получение таблицы сдвигов для "хороших" суффиксов
size_t* get_suffix_table(const char* s, size_t n)
{
	//получение таблицы хороших суффиксов:
	size_t* suffix = get_suffix(s, n);

	//максимально возможный сдвиг = расстоянию между префиксом и суффиксом всей строки [0 .. i] = [0 .. n-1],
	//длина префикса/суффика хранится в последней ячейке массива суффиксов:
	size_t max_shift = n - suffix[n - 1];

	//создание таблицы сдвигов на базе хороших суффиксов:
	size_t* table = malloc(sizeof(size_t) * n);

	if (table == NULL)
	{
		exit(MEMORY_ALLOCATION_ERROR);
	}

	//изначально заполняем все ячейки максимально возможными значениями сдвигов:
	for (size_t i = 0; i < n; ++i)
	{
		table[i] = max_shift;
	}

	//для подстрок [0 .. i] (на перевёрнутой строке) перебираем длины суффиксов, но с 1-й позиции,
	//т.к. собственный суффикс должен быть не равен самой строке, что невозможно для строки из 1-го элемента.
	for (size_t i = 1; i < n; ++i)
	{
		//suffix[i] - количество символов суффикса, совпавших с префиксом (в начале),
		//suffix[i] - в то же время: позиция первого несовпавшего (т.е. за префиксом):
		size_t bad_index = suffix[i];

		//если сдвиг ещё не был записан в таблицу, обновляем его:
		//(таким образом, для повторяющегося суффикса записывается минимальное расстояние от этого суффикса до префикса):
		if (table[bad_index] == max_shift)
		{
			table[bad_index] = i + 1 - suffix[i];
		}
		//table[bad_index] = min(table[bad_index], i + 1 - suffix[i]);
	}

	//переворот массива суффиксов (т.к. изначально он строился для перевёрнутой строки, а не оригинальной):
	reverse(table, n);

	//возврат таблицы сдвигов суффиксов:
	return table;
}

//Алгоритм Бойера-Мура
size_t BM(const char* string, const char* pattern)
{
	//считаем длины строк:
	size_t n = strlen(string);
	size_t m = strlen(pattern);

	//подсчитываем таблицы сдвигов для "плохого" символа и "хорошего" суффикса:
	size_t* symbol_table = get_symbol_table(pattern, m);
	size_t* suffix_table = get_suffix_table(pattern, m);

	//вводим начальные значения счётчиков:
	size_t i = m - 1, j = m - 1;
	//количество совпавших символов:
	size_t p = 0;

	//пока строка, в которой ищем, не закончилась:
	while (i < n)
	{
		//если символы совпали:
		if (string[i - p] == pattern[j - p])
		{
			//то увеличиваем счётчик совпавших:
			++p;

			//если количество совпавших равно длине паттерна, то подстрока найдена, выходим:
			if (p == m)
			{
				free(symbol_table);
				free(suffix_table);
				//рассчитываем позицию первого символа в строке для поиска:
				return i - j;
			}
		}
		//если символы НЕ совпали:
		else
		{
			//если не совпал последний символ:
			if (p == 0)
			{
				//сдвиг по правилу "плохого" символа:
				unsigned char index = string[i];
				i += symbol_table[index];
			}
			//если не совпал НЕ последний символ (т.е. накопился совпавший суффикс):
			else
			{
				//сдвиг по правилу "хорошего" суффикса:
				i += suffix_table[j];
			}

			//начинаем проверку сначала:
			p = 0;
		}
	}

	free(symbol_table);
	free(suffix_table);

	//в случае неуспеха возвращаем позицию -1:
	return NOT_A_POSITION;
}

